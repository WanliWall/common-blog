> 随笔

### 代码执行的两个阶段

1. 代码预编译阶段
   - 在预编译阶段进行变量声明
   - 在预编译阶段对变量进行提升，但是值为 `undefined`
   - 在预编译阶段对所有非表达式的函数声明进行提升
2. 代码执行阶段

小结：作用域在编译阶段确定，但是作用域链是在执行上下文的创建完成生成的，函数在调用的时候才会开始创建对应的执行上下文，执行上下文包括变量对象、作用域链、`this` 的指向

### javaSCript 引擎机制最基本的原理

- 代码的整个过程说起来就像一条流水线，第一道工序是在 **预编译** 阶段创建变量对象 （Variable Object. VO），此时只是创建，而未进行赋值。到了下一道工序 **代码执行** 阶段，变量对象会转为激活对象（Active Object, AO），即完成 VO 向 AO 的转换。此时，作用域链也将被确定，它由当前环境执行的变量对象和所有外层已经完成的激活对象组成。这道工序保证了变量和函数的有序访问，即如果在当前作用域内找不到变量，则会继续向上查找，直到全局作用域

### 调用栈

````javascript
foo1(){
  foo2()
}
foo2(){
  foo3()
}
foo3(){
  foo4()
}
foo4(){
  console.log()
}
foo1()
````

上面函数的调用栈为：执行 `foo1()` 函数后，`foo1` 入栈  --> `foo2` 入栈 --> `foo3` 入栈 --> `foo4` 入栈，执行完毕后，`foo4` 出栈 --> `foo3` 出栈 --> `foo2` 出栈 --> `foo1` 出栈，整个过程满足 **先进后出** 的规则，因此形成调用栈。

在函数执行完并出栈时，函数内的局部变量在下一个垃圾回收（`GC`）节点被回收，该函数对应的执行上下文将会被销毁，这也正是在外界无法访问到函数内部定义的变量的原因，也就是说，只有在函数执行完时，相关的函数才可以访问该变量，该变量会在预编译阶段被创建，在执行阶段被激活，在函数执行完毕后，其相关上下文会被销毁。

### 闭包的基本原理

- 正常情况下外界是无法访问到函数内部的变量，函数执行之后，上下文即被销毁。但是在函数（这里指外层函数）中，如果我们返回了另一个函数，且这个返回的函数使用了函数（这里指外层函数）内的变量，那么外界便能够通过这个返回的函数获取原函数（这里指外层函数）内部的变量值

  ````javascript
  function foo(){
    const NUM = 30
    return function() {
      console.log(NUM)
    }
  }
  let fooCopy = foo()
  fooCopy()
  ````

- 总结一句话：内部函数访问外部函数的局部变量就会产生闭包
